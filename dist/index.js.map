{
  "version": 3,
  "sources": ["../lib/base.js", "../lib/zlaswp.js", "../lib/ndarray.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major' );\nvar reinterpret = require( '@stdlib/strided-base-reinterpret-complex128' );\nvar floor = require( '@stdlib/math-base-special-floor' );\nvar zswap = require( '@stdlib/blas-base-zswap' ).ndarray;\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* var Int32Array = require( '@stdlib/array-int32' );\n* var Complex128Array = require( '@stdlib/array-complex128' );\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar viewA;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `zswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tzswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\tviewA = reinterpret( A, 0 );\n\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\toffsetA *= 2;\n\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaswp;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isLayout = require( '@stdlib/blas-base-assert-is-layout' );\nvar isRowMajor = require( '@stdlib/ndarray-base-assert-is-row-major-string' );\nvar isColumnMajor = require( '@stdlib/ndarray-base-assert-is-column-major-string' );\nvar max = require( '@stdlib/math-base-special-max' );\nvar format = require( '@stdlib/string-format' );\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* var Int32Array = require( '@stdlib/array-int32' );\n* var Complex128Array = require( '@stdlib/array-complex128' );\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( isRowMajor( order ) && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( isColumnMajor( order ) ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaswp;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar base = require( './base.js' );\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* var Int32Array = require( '@stdlib/array-int32' );\n* var Complex128Array = require( '@stdlib/array-complex128' );\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaswp;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar zlaswp = require( './zlaswp.js' );\nvar ndarray = require( './ndarray.js' );\n\n\n// MAIN //\n\nsetReadOnly( zlaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nmodule.exports = zlaswp;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack-base-zlaswp\n*\n* @example\n* var Int32Array = require( '@stdlib/array-int32' );\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var zlaswp = require( '@stdlib/lapack-base-zlaswp' );\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*\n* @example\n* var Int32Array = require( '@stdlib/array-int32' );\n* var Complex128Array = require( '@stdlib/array-complex128' );\n* var zlaswp = require( '@stdlib/lapack-base-zlaswp' );\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp.ndarray( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nvar tryRequire = require( '@stdlib/utils-try-require' );\nvar isError = require( '@stdlib/assert-is-error' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\nvar zlaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlaswp = main;\n} else {\n\tzlaswp = tmp;\n}\n\n\n// EXPORTS //\n\nmodule.exports = zlaswp;\n\n// exports: { \"ndarray\": \"zlaswp.ndarray\" }\n"],
  "mappings": "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",
  "names": ["require_base", "__commonJSMin", "exports", "module", "isRowMajor", "reinterpret", "floor", "zswap", "BLOCK_SIZE", "zlaswp", "N", "A", "strideA1", "strideA2", "offsetA", "k1", "k2", "inck", "IPIV", "strideIPIV", "offsetIPIV", "nrows", "viewA", "n32", "tmp", "row", "ia1", "ia2", "ip", "i", "j", "k", "n", "o", "require_zlaswp", "__commonJSMin", "exports", "module", "isLayout", "isRowMajor", "isColumnMajor", "max", "format", "base", "zlaswp", "order", "N", "A", "LDA", "k1", "k2", "IPIV", "incx", "tmp", "inc", "sa1", "sa2", "io", "require_ndarray", "__commonJSMin", "exports", "module", "base", "zlaswp", "N", "A", "strideA1", "strideA2", "offsetA", "k1", "k2", "inck", "IPIV", "strideIPIV", "offsetIPIV", "tmp", "require_main", "__commonJSMin", "exports", "module", "setReadOnly", "zlaswp", "ndarray", "join", "tryRequire", "isError", "main", "zlaswp", "tmp"]
}
