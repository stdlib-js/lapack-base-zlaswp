{"version":3,"file":"index.mjs","sources":["../lib/base.js","../lib/zlaswp.js","../lib/main.js","../lib/ndarray.js","../lib/index.js","../a34cf9316b8d5567a5f9f19c1f5138"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isRowMajor from '@stdlib/ndarray-base-assert-is-row-major';\nimport reinterpret from '@stdlib/strided-base-reinterpret-complex128';\nimport floor from '@stdlib/math-base-special-floor';\nimport { ndarray as zswap } from '@stdlib/blas-base-zswap';\n\n\n// VARIABLES //\n\nvar BLOCK_SIZE = 32;\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @private\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array-int32';\n* import Complex128Array from '@stdlib/array-complex128';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar nrows;\n\tvar viewA;\n\tvar n32;\n\tvar tmp;\n\tvar row;\n\tvar ia1;\n\tvar ia2;\n\tvar ip;\n\tvar i;\n\tvar j;\n\tvar k;\n\tvar n;\n\tvar o;\n\n\t// Compute the number of rows to be interchanged:\n\tif ( inck > 0 ) {\n\t\tnrows = k2 - k1;\n\t} else {\n\t\tnrows = k1 - k2;\n\t}\n\tnrows += 1;\n\n\t// If the order is row-major, we can delegate to the Level 1 routine `zswap` for interchanging rows...\n\tif ( isRowMajor( [ strideA1, strideA2 ] ) ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tzswap( N, A, strideA2, offsetA+(k*strideA1), A, strideA2, offsetA+(row*strideA1) ); // eslint-disable-line max-len\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t\treturn A;\n\t}\n\tviewA = reinterpret( A, 0 );\n\n\tstrideA1 *= 2;\n\tstrideA2 *= 2;\n\toffsetA *= 2;\n\n\t// If the order is column-major, we need to use loop tiling to ensure efficient cache access when accessing matrix elements...\n\tn32 = floor( N/BLOCK_SIZE ) * BLOCK_SIZE;\n\tif ( n32 !== 0 ) {\n\t\tfor ( j = 0; j < n32; j += BLOCK_SIZE ) {\n\t\t\tip = offsetIPIV;\n\t\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\t\trow = IPIV[ ip ];\n\t\t\t\tif ( row !== k ) {\n\t\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\t\tfor ( n = j; n < j+BLOCK_SIZE; n++ ) {\n\t\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tip += strideIPIV;\n\t\t\t}\n\t\t}\n\t}\n\tif ( n32 !== N ) {\n\t\tip = offsetIPIV;\n\t\tfor ( i = 0, k = k1; i < nrows; i++, k += inck ) {\n\t\t\trow = IPIV[ ip ];\n\t\t\tif ( row !== k ) {\n\t\t\t\tia1 = offsetA + ( k*strideA1 );\n\t\t\t\tia2 = offsetA + ( row*strideA1 );\n\t\t\t\tfor ( n = n32; n < N; n++ ) {\n\t\t\t\t\to = n * strideA2;\n\n\t\t\t\t\ttmp = viewA[ ia1+o ];\n\t\t\t\t\tviewA[ ia1+o ] = viewA[ ia2+o ];\n\t\t\t\t\tviewA[ ia2+o ] = tmp;\n\n\t\t\t\t\ttmp = viewA[ ia1+o+1 ];\n\t\t\t\t\tviewA[ ia1+o+1 ] = viewA[ ia2+o+1 ];\n\t\t\t\t\tviewA[ ia2+o+1 ] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tip += strideIPIV;\n\t\t}\n\t}\n\treturn A;\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isLayout from '@stdlib/blas-base-assert-is-layout';\nimport max from '@stdlib/math-base-special-max';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {string} order - storage layout\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {PositiveInteger} LDA - stride of the first dimension of `A` (a.k.a., leading dimension of the matrix `A`)\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} incx - increment between successive values of `IPIV`\n* @throws {TypeError} first argument must be a valid order\n* @throws {RangeError} fourth argument must be greater than or equal to max(1,N)\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array-int32';\n* import Complex128Array from '@stdlib/array-complex128';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( order, N, A, LDA, k1, k2, IPIV, incx ) {\n\tvar tmp;\n\tvar inc;\n\tvar sa1;\n\tvar sa2;\n\tvar io;\n\tif ( !isLayout( order ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a valid order. Value: `%s`.', order ) );\n\t}\n\tif ( order === 'row-major' && LDA < max( 1, N ) ) {\n\t\tthrow new RangeError( format( 'invalid argument. Fourth argument must be greater than or equal to max(1,%d). Value: `%d`.', N, LDA ) );\n\t}\n\tif ( incx > 0 ) {\n\t\tinc = 1;\n\t\tio = k1;\n\t} else if ( incx < 0 ) {\n\t\tinc = -1;\n\t\tio = k1 + ( (k1-k2) * incx );\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t} else {\n\t\treturn A;\n\t}\n\tif ( order === 'column-major' ) {\n\t\tsa1 = 1;\n\t\tsa2 = LDA;\n\t} else { // order === 'row-major'\n\t\tsa1 = LDA;\n\t\tsa2 = 1;\n\t}\n\treturn base( N, A, sa1, sa2, 0, k1, k2, inc, IPIV, incx, io );\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport zlaswp from './zlaswp.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zlaswp, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport base from './base.js';\n\n\n// MAIN //\n\n/**\n* Performs a series of row interchanges on a matrix `A` using pivot indices stored in `IPIV`.\n*\n* @param {PositiveInteger} N - number of columns in `A`\n* @param {Complex128Array} A - input matrix\n* @param {integer} strideA1 - stride of the first dimension of `A`\n* @param {integer} strideA2 - stride of the second dimension of `A`\n* @param {NonNegativeInteger} offsetA - index offset for `A`\n* @param {NonNegativeInteger} k1 - index of first row to interchange\n* @param {NonNegativeInteger} k2 - index of last row to interchange\n* @param {integer} inck - direction in which to apply pivots (-1 to apply pivots in reverse order; otherwise, apply in provided order)\n* @param {Int32Array} IPIV - vector of pivot indices\n* @param {integer} strideIPIV - `IPIV` stride length\n* @param {NonNegativeInteger} offsetIPIV - index offset for `IPIV`\n* @returns {Complex128Array} permuted matrix `A`\n*\n* @example\n* import Int32Array from '@stdlib/array-int32';\n* import Complex128Array from '@stdlib/array-complex128';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\nfunction zlaswp( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ) { // eslint-disable-line max-len, max-params\n\tvar tmp;\n\tif ( inck < 0 ) {\n\t\toffsetIPIV += k2 * strideIPIV;\n\t\tstrideIPIV *= -1;\n\t\ttmp = k1;\n\t\tk1 = k2;\n\t\tk2 = tmp;\n\t\tinck = -1;\n\t} else {\n\t\toffsetIPIV += k1 * strideIPIV;\n\t\tinck = 1;\n\t}\n\treturn base( N, A, strideA1, strideA2, offsetA, k1, k2, inck, IPIV, strideIPIV, offsetIPIV ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* LAPACK routine to perform a series of row interchanges on an input matrix.\n*\n* @module @stdlib/lapack-base-zlaswp\n*\n* @example\n* import Int32Array from '@stdlib/array-int32';\n* import Complex128Array from '@stdlib/array-complex128';\n* import zlaswp from '@stdlib/lapack-base-zlaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp( 'row-major', 2, A, 2, 0, 2, IPIV, 1 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*\n* @example\n* import Int32Array from '@stdlib/array-int32';\n* import Complex128Array from '@stdlib/array-complex128';\n* import zlaswp from '@stdlib/lapack-base-zlaswp';\n*\n* var IPIV = new Int32Array( [ 2, 0, 1 ] );\n* var A = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n*\n* zlaswp.ndarray( 2, A, 2, 1, 0, 0, 2, 1, IPIV, 1, 0 );\n* // A => <Complex128Array>[ 5.0, 6.0, 7.0, 8.0, 1.0, 2.0, 3.0, 4.0, 9.0, 10.0, 11.0, 12.0 ]\n*/\n\n// MODULES //\n\nvar join = require( 'path' ).join;\nimport tryRequire from '@stdlib/utils-try-require';\nimport isError from '@stdlib/assert-is-error';\nimport main from './main.js';\n\n\n// MAIN //\n\nvar zlaswp;\nvar tmp = tryRequire( join( __dirname, './native.js' ) );\nif ( isError( tmp ) ) {\n\tzlaswp = main;\n} else {\n\tzlaswp = tmp;\n}\n\n\n// EXPORTS //\n\nexport default zlaswp;\n","export default '/home/runner/work/lapack-base-zlaswp/lapack-base-zlaswp/lib'"],"names":["BLOCK_SIZE","zlaswp","N","A","strideA1","strideA2","offsetA","k1","k2","inck","IPIV","strideIPIV","offsetIPIV","nrows","viewA","n32","tmp","row","ia1","ia2","ip","i","j","k","n","o","isRowMajor","zswap","reinterpret","floor","order","LDA","incx","inc","sa1","sa2","io","isLayout","TypeError","format","max","RangeError","base","setReadOnly","tryRequire","join","require$$0","zlaswp$1","isError","main"],"mappings":"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"}